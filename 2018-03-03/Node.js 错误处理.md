# Node.js 错误处理

## 一个简单的案例
JavaScript中的错误处理使用 try...catch 代码块。Node.js 使用非阻塞IO和异步函数回调，但这也会带来新的问题。

```js
	try {
		setTimeout(function() {
			throw new Error("Wow, error !");
		}, 2000)
	} catch (e) {
		console.log("I caught an error: " + e.message);
	}
```

如果运行以上代码，期望能看到输出结果为“I caught an error: Wow, error !”。但是可惜的是并非如此,我们会得到一些意想不到的信息。为什么会这样?难道try...catch代码块不会捕获错误么?不，它 会捕获错误。但是，异步回调会给捕获错误带来一点小麻烦。


事实上，对setTimeout的调用的确是在try...catch代码块中执行 的。如果函数抛出错误，catch就会捕获它，然后你就能看到期望的 结果了。但是setTimeout函数只是在Node的事件队列中添加了一个 新事件(是为了告诉Node在给定的等待时间以后调用该函数——在 本例中是2000ms)，然后返回。而这个回调函数实际上是在一个全 新的上下文和作用域中执行的。因此，当在非阻塞IO中调用异步函数的时候，只有极小一部分 会抛出错误;大部分情况下，编译器会告诉你出错了。在Node中，我们使用一些核心模式(core pattern)来帮助规 范化编码，以避免出错。这些模式不是JavaScript这门语言或者引擎强制要求的，但经常可以在项目中看到这些模式，甚至你也会自己使 用到这些模式。## 回调函数和错误处理

你第一个会看到的模式就是格式化传递给异步函数使用的回调函 数。回调函数一般至少包含一个参数，即最后操作的成功或者失败状 态;一般也会包含第二个参数，即最后操作返回的结果或信息(比如 文件句柄、数据库连接、查询到的数据集等);一些回调函数还可能包含更多的参数。

参数err的值一般会是:

- null，表明操作成功，并且会有一个返回值(如果有需要的话)。
- 一个Error对象的实例，你偶尔会看到一些不一致的地方:有 些人喜欢在Error对象上添加code字段，并且用message字段保存错 误信息;反之，有些人喜欢用一些其他的模式。本书中的所有代码使 用的模式都会包含code字段，并使用message字段来尽可能提供更 多的错误信息。所有的模块中code字段都是字符串类型，因为这样 更具可读性。一些类库则会在Error对象中提供更多的信息，但至少 要包含上述两个字段。我们将呈现使用回调函数中处理错误的两种不同的代码风格，并使用一个典型的案例来编写完善的错误处理代码。
